import { info, warn, error } from "../core/logger/core.js";
import { getParamsAndProps, GetParamsAndPropsError } from "../core/render/core.js";
import { createRouteManifest, matchRoute } from "../core/routing/index.js";
import stripAnsi from "strip-ansi";
import { createSafeError, resolvePages, isBuildingToSSR } from "../core/util.js";
import { ssr, preload } from "../core/render/dev/index.js";
import { call as callEndpoint } from "../core/endpoint/dev/index.js";
import * as msg from "../core/messages.js";
import notFoundTemplate, { subpathNotUsedTemplate } from "../template/4xx.js";
import serverErrorTemplate from "../template/5xx.js";
import { RouteCache } from "../core/render/route-cache.js";
import { fixViteErrorMessage } from "../core/errors.js";
import { createRequest } from "../core/request.js";
import { Readable } from "stream";
const BAD_VITE_MIDDLEWARE = [
  "viteIndexHtmlMiddleware",
  "vite404Middleware",
  "viteSpaFallbackMiddleware"
];
function removeViteHttpMiddleware(server) {
  for (let i = server.stack.length - 1; i > 0; i--) {
    if (BAD_VITE_MIDDLEWARE.includes(server.stack[i].handle.name)) {
      server.stack.splice(i, 1);
    }
  }
}
function writeHtmlResponse(res, statusCode, html) {
  res.writeHead(statusCode, {
    "Content-Type": "text/html; charset=utf-8",
    "Content-Length": Buffer.byteLength(html, "utf-8")
  });
  res.write(html);
  res.end();
}
async function writeWebResponse(res, webResponse) {
  const { status, headers, body } = webResponse;
  res.writeHead(status, Object.fromEntries(headers.entries()));
  if (body) {
    if (body instanceof Readable) {
      body.pipe(res);
      return;
    } else {
      const reader = body.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        if (value) {
          res.write(value);
        }
      }
    }
  }
  res.end();
}
async function writeSSRResult(result, res, statusCode) {
  if (result.type === "response") {
    const { response } = result;
    await writeWebResponse(res, response);
    return;
  }
  const { html } = result;
  writeHtmlResponse(res, statusCode, html);
}
async function handle404Response(origin, config, req, res) {
  const site = config.site ? new URL(config.base, config.site) : void 0;
  const devRoot = site ? site.pathname : "/";
  const pathname = decodeURI(new URL(origin + req.url).pathname);
  let html = "";
  if (pathname === "/" && !pathname.startsWith(devRoot)) {
    html = subpathNotUsedTemplate(devRoot, pathname);
  } else {
    html = notFoundTemplate({
      statusCode: 404,
      title: "Not found",
      tabTitle: "404: Not Found",
      pathname
    });
  }
  writeHtmlResponse(res, 404, html);
}
async function handle500Response(viteServer, origin, req, res, err) {
  const pathname = decodeURI(new URL(origin + req.url).pathname);
  const html = serverErrorTemplate({
    statusCode: 500,
    title: "Internal Error",
    tabTitle: "500: Error",
    message: stripAnsi(err.message),
    url: err.url || void 0,
    stack: stripAnsi(err.stack)
  });
  const transformedHtml = await viteServer.transformIndexHtml(pathname, html, pathname);
  writeHtmlResponse(res, 500, transformedHtml);
}
function getCustom404Route(config, manifest) {
  const relPages = resolvePages(config).href.replace(config.root.href, "");
  return manifest.routes.find((r) => r.component === relPages + "404.astro");
}
function log404(logging, pathname) {
  info(logging, "serve", msg.req({ url: pathname, statusCode: 404 }));
}
async function handleRequest(routeCache, viteServer, logging, manifest, config, req, res) {
  const reqStart = performance.now();
  const site = config.site ? new URL(config.base, config.site) : void 0;
  const devRoot = site ? site.pathname : "/";
  const origin = `${viteServer.config.server.https ? "https" : "http"}://${req.headers.host}`;
  const buildingToSSR = isBuildingToSSR(config);
  const url = new URL(origin + req.url);
  const pathname = decodeURI(url.pathname);
  const rootRelativeUrl = pathname.substring(devRoot.length - 1);
  if (!buildingToSSR) {
    for (const [key] of url.searchParams) {
      url.searchParams.delete(key);
    }
  }
  let body = void 0;
  if (!(req.method === "GET" || req.method === "HEAD")) {
    let bytes = [];
    await new Promise((resolve) => {
      req.setEncoding("utf-8");
      req.on("data", (bts) => bytes.push(bts));
      req.on("end", resolve);
    });
    body = new TextEncoder().encode(bytes.join("")).buffer;
  }
  const request = createRequest({
    url,
    headers: buildingToSSR ? req.headers : new Headers(),
    method: req.method,
    body,
    logging
  });
  try {
    if (!pathname.startsWith(devRoot)) {
      log404(logging, pathname);
      return handle404Response(origin, config, req, res);
    }
    let route = matchRoute(rootRelativeUrl, manifest);
    const statusCode = route ? 200 : 404;
    if (!route) {
      log404(logging, pathname);
      const custom404 = getCustom404Route(config, manifest);
      if (custom404) {
        route = custom404;
      } else {
        return handle404Response(origin, config, req, res);
      }
    }
    const filePath = new URL(`./${route.component}`, config.root);
    const preloadedComponent = await preload({ astroConfig: config, filePath, viteServer });
    const [, mod] = preloadedComponent;
    const paramsAndPropsRes = await getParamsAndProps({
      mod,
      route,
      routeCache,
      pathname: rootRelativeUrl,
      logging,
      ssr: isBuildingToSSR(config)
    });
    if (paramsAndPropsRes === GetParamsAndPropsError.NoMatchingStaticPath) {
      warn(logging, "getStaticPaths", `Route pattern matched, but no matching static path found. (${pathname})`);
      log404(logging, pathname);
      const routeCustom404 = getCustom404Route(config, manifest);
      if (routeCustom404) {
        const filePathCustom404 = new URL(`./${routeCustom404.component}`, config.root);
        const preloadedCompCustom404 = await preload({
          astroConfig: config,
          filePath: filePathCustom404,
          viteServer
        });
        const result = await ssr(preloadedCompCustom404, {
          astroConfig: config,
          filePath: filePathCustom404,
          logging,
          mode: "development",
          origin,
          pathname: rootRelativeUrl,
          request,
          route: routeCustom404,
          routeCache,
          viteServer
        });
        return await writeSSRResult(result, res, statusCode);
      } else {
        return handle404Response(origin, config, req, res);
      }
    }
    const options = {
      astroConfig: config,
      filePath,
      logging,
      mode: "development",
      origin,
      pathname: rootRelativeUrl,
      route,
      routeCache,
      viteServer,
      request
    };
    if (route.type === "endpoint") {
      const result = await callEndpoint(options);
      if (result.type === "response") {
        await writeWebResponse(res, result.response);
      } else {
        res.writeHead(200);
        res.end(result.body);
      }
    } else {
      const result = await ssr(preloadedComponent, options);
      return await writeSSRResult(result, res, statusCode);
    }
  } catch (_err) {
    debugger;
    const err = fixViteErrorMessage(createSafeError(_err), viteServer);
    error(logging, null, msg.formatErrorMessage(err));
    handle500Response(viteServer, origin, req, res, err);
  }
}
function createPlugin({ config, logging }) {
  return {
    name: "astro:server",
    configureServer(viteServer) {
      let routeCache = new RouteCache(logging);
      let manifest = createRouteManifest({ config }, logging);
      function rebuildManifest(needsManifestRebuild, file) {
        routeCache.clearAll();
        if (needsManifestRebuild) {
          manifest = createRouteManifest({ config }, logging);
        }
      }
      viteServer.watcher.on("add", rebuildManifest.bind(null, true));
      viteServer.watcher.on("unlink", rebuildManifest.bind(null, true));
      viteServer.watcher.on("change", rebuildManifest.bind(null, false));
      return () => {
        removeViteHttpMiddleware(viteServer.middlewares);
        viteServer.middlewares.use(async (req, res) => {
          if (!req.url || !req.method) {
            throw new Error("Incomplete request");
          }
          handleRequest(routeCache, viteServer, logging, manifest, config, req, res);
        });
      };
    }
  };
}
export {
  createPlugin as default
};
