import { warn, debug } from "../logger/core.js";
import { generatePaginateFunction } from "./paginate.js";
import {
  validateGetStaticPathsModule,
  validateGetStaticPathsResult
} from "../routing/validation.js";
function stringifyParams(params) {
  return JSON.stringify(params, Object.keys(params).sort());
}
async function callGetStaticPaths({
  isValidate,
  logging,
  mod,
  route,
  ssr
}) {
  validateGetStaticPathsModule(mod, { ssr });
  const resultInProgress = {
    rss: []
  };
  let staticPaths = [];
  if (mod.getStaticPaths) {
    staticPaths = (await mod.getStaticPaths({
      paginate: generatePaginateFunction(route),
      rss: (data) => {
        resultInProgress.rss.push(data);
      }
    })).flat();
  }
  const keyedStaticPaths = staticPaths;
  keyedStaticPaths.keyed = /* @__PURE__ */ new Map();
  for (const sp of keyedStaticPaths) {
    const paramsKey = stringifyParams(sp.params);
    keyedStaticPaths.keyed.set(paramsKey, sp);
  }
  if (isValidate) {
    validateGetStaticPathsResult(keyedStaticPaths, logging);
  }
  return {
    rss: resultInProgress.rss,
    staticPaths: keyedStaticPaths
  };
}
class RouteCache {
  constructor(logging) {
    this.cache = {};
    this.logging = logging;
  }
  clearAll() {
    this.cache = {};
  }
  set(route, entry) {
    if (this.cache[route.component]) {
      warn(this.logging, "routeCache", `Internal Warning: route cache overwritten. (${route.component})`);
    }
    this.cache[route.component] = entry;
  }
  get(route) {
    return this.cache[route.component];
  }
}
function findPathItemByKey(staticPaths, params) {
  const paramsKey = stringifyParams(params);
  let matchedStaticPath = staticPaths.keyed.get(paramsKey);
  if (matchedStaticPath) {
    return matchedStaticPath;
  }
  debug("findPathItemByKey", `Unexpected cache miss looking for ${paramsKey}`);
  matchedStaticPath = staticPaths.find(({ params: _params }) => JSON.stringify(_params) === paramsKey);
}
export {
  RouteCache,
  callGetStaticPaths,
  findPathItemByKey
};
