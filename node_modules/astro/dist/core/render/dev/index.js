var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import astroRemark from "@astrojs/markdown-remark";
import { fileURLToPath } from "url";
import { render as coreRender } from "../core.js";
import { prependForwardSlash } from "../../../core/path.js";
import { createModuleScriptElementWithSrcSet } from "../ssr-element.js";
import { getStylesForURL } from "./css.js";
import { getHmrScript } from "./hmr.js";
import { injectTags } from "./html.js";
import { isBuildingToSSR } from "../../util.js";
const svelteStylesRE = /svelte\?svelte&type=style/;
async function loadRenderer(viteServer, renderer) {
  var _a;
  const id = ((_a = viteServer.moduleGraph.urlToModuleMap.get(renderer.serverEntrypoint)) == null ? void 0 : _a.id) ?? renderer.serverEntrypoint;
  const mod = await viteServer.ssrLoadModule(id);
  return __spreadProps(__spreadValues({}, renderer), { ssr: mod.default });
}
async function loadRenderers(viteServer, astroConfig) {
  return Promise.all(astroConfig._ctx.renderers.map((r) => loadRenderer(viteServer, r)));
}
async function preload({
  astroConfig,
  filePath,
  viteServer
}) {
  const renderers = await loadRenderers(viteServer, astroConfig);
  const mod = await viteServer.ssrLoadModule(fileURLToPath(filePath));
  return [renderers, mod];
}
async function render(renderers, mod, ssrOpts) {
  const {
    astroConfig,
    filePath,
    logging,
    mode,
    origin,
    pathname,
    request,
    route,
    routeCache,
    viteServer
  } = ssrOpts;
  const isLegacyBuild = false;
  const scripts = createModuleScriptElementWithSrcSet(!isLegacyBuild && mod.hasOwnProperty("$$metadata") ? Array.from(mod.$$metadata.hoistedScriptPaths()) : []);
  if (mod.hasOwnProperty("$$metadata") && mode === "development" && !isLegacyBuild) {
    scripts.add({
      props: { type: "module", src: "/@vite/client" },
      children: ""
    });
    scripts.add({
      props: {
        type: "module",
        src: new URL("../../../runtime/client/hmr.js", import.meta.url).pathname
      },
      children: ""
    });
  }
  for (const script of astroConfig._ctx.scripts) {
    if (script.stage === "head-inline") {
      scripts.add({
        props: {},
        children: script.content
      });
    }
  }
  let links = /* @__PURE__ */ new Set();
  if (!isLegacyBuild) {
    [...getStylesForURL(filePath, viteServer)].forEach((href) => {
      if (mode === "development" && svelteStylesRE.test(href)) {
        scripts.add({
          props: { type: "module", src: href },
          children: ""
        });
      } else {
        links.add({
          props: {
            rel: "stylesheet",
            href,
            "data-astro-injected": true
          },
          children: ""
        });
      }
    });
  }
  let content = await coreRender({
    legacyBuild: isLegacyBuild,
    links,
    logging,
    markdownRender: [astroRemark, astroConfig.markdown],
    mod,
    origin,
    pathname,
    scripts,
    async resolve(s) {
      const [resolvedUrl, resolvedPath] = await viteServer.moduleGraph.resolveUrl(s);
      if (resolvedPath.includes("node_modules/.vite")) {
        return resolvedPath.replace(/.*?node_modules\/\.vite/, "/node_modules/.vite");
      }
      if (!resolvedUrl.startsWith(".") && !resolvedUrl.startsWith("/")) {
        return "/@id" + prependForwardSlash(resolvedUrl);
      }
      return "/@fs" + prependForwardSlash(resolvedPath);
    },
    renderers,
    request,
    route,
    routeCache,
    site: astroConfig.site ? new URL(astroConfig.base, astroConfig.site).toString() : void 0,
    ssr: isBuildingToSSR(astroConfig)
  });
  if ((route == null ? void 0 : route.type) === "endpoint" || content.type === "response") {
    return content;
  }
  const tags = [];
  if (mode === "development" && isLegacyBuild) {
    tags.push({
      tag: "script",
      attrs: { type: "module" },
      children: await getHmrScript(),
      injectTo: "head"
    });
  }
  if (isLegacyBuild) {
    [...getStylesForURL(filePath, viteServer)].forEach((href) => {
      if (mode === "development" && svelteStylesRE.test(href)) {
        tags.push({
          tag: "script",
          attrs: { type: "module", src: href },
          injectTo: "head"
        });
      } else {
        tags.push({
          tag: "link",
          attrs: {
            rel: "stylesheet",
            href,
            "data-astro-injected": true
          },
          injectTo: "head"
        });
      }
    });
  }
  let html = injectTags(content.html, tags);
  if (!/<!doctype html/i.test(html)) {
    html = "<!DOCTYPE html>\n" + content;
  }
  return {
    type: "html",
    html
  };
}
async function ssr(preloadedComponent, ssrOpts) {
  const [renderers, mod] = preloadedComponent;
  return await render(renderers, mod, ssrOpts);
}
export {
  loadRenderers,
  preload,
  render,
  ssr
};
