import { info } from "../logger/core.js";
import { fileURLToPath } from "url";
import * as colors from "kleur/colors";
import { debug } from "../logger/core.js";
import { preload as ssrPreload } from "../render/dev/index.js";
import { generateRssFunction } from "../render/rss.js";
import { callGetStaticPaths } from "../render/route-cache.js";
import { isBuildingToSSR } from "../util.js";
async function collectPagesData(opts) {
  var _a;
  const { astroConfig, logging, manifest, origin, routeCache, viteServer } = opts;
  const assets = {};
  const allPages = {};
  const buildMode = isBuildingToSSR(astroConfig) ? "ssr" : "static";
  const dataCollectionLogTimeout = setInterval(() => {
    info(opts.logging, "build", "The data collection step may take longer for larger projects...");
    clearInterval(dataCollectionLogTimeout);
  }, 3e4);
  for (const route of manifest.routes) {
    if (route.pathname) {
      const routeCollectionLogTimeout = setInterval(() => {
        info(opts.logging, "build", `${colors.bold(route.component)} is taking a bit longer to import. This is common for larger "Astro.glob(...)" or "import.meta.globEager(...)" calls, for instance. Hang tight!`);
        clearInterval(routeCollectionLogTimeout);
      }, 1e4);
      allPages[route.component] = {
        component: route.component,
        route,
        paths: [route.pathname],
        moduleSpecifier: "",
        css: /* @__PURE__ */ new Set(),
        hoistedScript: void 0,
        scripts: /* @__PURE__ */ new Set(),
        preload: await ssrPreload({
          astroConfig,
          filePath: new URL(`./${route.component}`, astroConfig.root),
          viteServer
        }).then((routes) => {
          clearInterval(routeCollectionLogTimeout);
          if (buildMode === "static") {
            const html = `${route.pathname}`.replace(/\/?$/, "/index.html");
            debug("build", `\u251C\u2500\u2500 ${colors.bold(colors.green("\u2714"))} ${route.component} \u2192 ${colors.yellow(html)}`);
          } else {
            debug("build", `\u251C\u2500\u2500 ${colors.bold(colors.green("\u2714"))} ${route.component}`);
          }
          return routes;
        }).catch((err) => {
          clearInterval(routeCollectionLogTimeout);
          debug("build", `\u251C\u2500\u2500 ${colors.bold(colors.red("\u2718"))} ${route.component}`);
          throw err;
        })
      };
      continue;
    }
    const result = await getStaticPathsForRoute(opts, route).then((_result) => {
      const label = _result.staticPaths.length === 1 ? "page" : "pages";
      debug("build", `\u251C\u2500\u2500 ${colors.bold(colors.green("\u2714"))} ${route.component} \u2192 ${colors.magenta(`[${_result.staticPaths.length} ${label}]`)}`);
      return _result;
    }).catch((err) => {
      debug("build", `\u251C\u2500\u2500 ${colors.bold(colors.red("\u2717"))} ${route.component}`);
      throw err;
    });
    const rssFn = generateRssFunction(astroConfig.site, route);
    for (const rssCallArg of result.rss) {
      const rssResult = rssFn(rssCallArg);
      if (rssResult.xml) {
        const { url, content } = rssResult.xml;
        if (content) {
          const rssFile = new URL(url.replace(/^\/?/, "./"), astroConfig.outDir);
          if (assets[fileURLToPath(rssFile)]) {
            throw new Error(`[getStaticPaths] RSS feed ${url} already exists.
Use \`rss(data, {url: '...'})\` to choose a unique, custom URL. (${route.component})`);
          }
          assets[fileURLToPath(rssFile)] = content;
        }
      }
      if ((_a = rssResult.xsl) == null ? void 0 : _a.content) {
        const { url, content } = rssResult.xsl;
        const stylesheetFile = new URL(url.replace(/^\/?/, "./"), astroConfig.outDir);
        if (assets[fileURLToPath(stylesheetFile)]) {
          throw new Error(`[getStaticPaths] RSS feed stylesheet ${url} already exists.
Use \`rss(data, {stylesheet: '...'})\` to choose a unique, custom URL. (${route.component})`);
        }
        assets[fileURLToPath(stylesheetFile)] = content;
      }
    }
    const finalPaths = result.staticPaths.map((staticPath) => staticPath.params && route.generate(staticPath.params)).filter(Boolean);
    allPages[route.component] = {
      component: route.component,
      route,
      paths: finalPaths,
      moduleSpecifier: "",
      css: /* @__PURE__ */ new Set(),
      hoistedScript: void 0,
      scripts: /* @__PURE__ */ new Set(),
      preload: await ssrPreload({
        astroConfig,
        filePath: new URL(`./${route.component}`, astroConfig.root),
        viteServer
      })
    };
  }
  clearInterval(dataCollectionLogTimeout);
  return { assets, allPages };
}
async function getStaticPathsForRoute(opts, route) {
  const { astroConfig, logging, routeCache, ssr, viteServer } = opts;
  if (!viteServer)
    throw new Error(`vite.createServer() not called!`);
  const filePath = new URL(`./${route.component}`, astroConfig.root);
  const mod = await viteServer.ssrLoadModule(fileURLToPath(filePath));
  const result = await callGetStaticPaths({ mod, route, isValidate: false, logging, ssr });
  routeCache.set(route, result);
  return result;
}
export {
  collectPagesData
};
