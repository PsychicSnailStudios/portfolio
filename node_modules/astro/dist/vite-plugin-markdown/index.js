var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import astroRemark from "@astrojs/markdown-remark";
import { transform } from "@astrojs/compiler";
import ancestor from "common-ancestor-path";
import esbuild from "esbuild";
import fs from "fs";
import matter from "gray-matter";
import { fileURLToPath } from "url";
import { PAGE_SSR_SCRIPT_ID } from "../vite-plugin-scripts/index.js";
import { virtualModuleId as pagesVirtualModuleId } from "../core/build/vite-plugin-pages.js";
import { appendForwardSlash } from "../core/path.js";
import { resolvePages } from "../core/util.js";
const VIRTUAL_MODULE_ID_PREFIX = "astro:markdown";
const VIRTUAL_MODULE_ID = "\0" + VIRTUAL_MODULE_ID_PREFIX;
function markdown({ config }) {
  function normalizeFilename(filename) {
    if (filename.startsWith("/@fs")) {
      filename = filename.slice("/@fs".length);
    } else if (filename.startsWith("/") && !ancestor(filename, config.root.pathname)) {
      filename = new URL("." + filename, config.root).pathname;
    }
    return filename;
  }
  const fakeRootImporter = fileURLToPath(new URL("index.html", config.root));
  function isRootImport(importer) {
    if (!importer) {
      return true;
    }
    if (importer === fakeRootImporter) {
      return true;
    }
    if (importer === "\0" + pagesVirtualModuleId) {
      return true;
    }
    return false;
  }
  return {
    name: "astro:markdown",
    enforce: "pre",
    async resolveId(id, importer, options) {
      if (id.startsWith(VIRTUAL_MODULE_ID)) {
        return id;
      }
      if (id.endsWith(".md?content")) {
        const resolvedId = await this.resolve(id, importer, __spreadValues({ skipSelf: true }, options));
        return resolvedId == null ? void 0 : resolvedId.id.replace("?content", "");
      }
      if (id.endsWith(".md") && !isRootImport(importer)) {
        const resolvedId = await this.resolve(id, importer, __spreadValues({ skipSelf: true }, options));
        if (resolvedId) {
          return VIRTUAL_MODULE_ID + resolvedId.id;
        }
      }
      return void 0;
    },
    async load(id) {
      if (id.startsWith(VIRTUAL_MODULE_ID)) {
        const sitePathname = config.site ? appendForwardSlash(new URL(config.base, config.site).pathname) : "/";
        const fileId = id.substring(VIRTUAL_MODULE_ID.length);
        const fileUrl = fileId.includes("/pages/") ? fileId.replace(/^.*\/pages\//, sitePathname).replace(/(\/index)?\.md$/, "") : void 0;
        const source = await fs.promises.readFile(fileId, "utf8");
        const { data: frontmatter } = matter(source);
        return {
          code: `   
						// Static
						export const frontmatter = ${JSON.stringify(frontmatter)};
						export const file = ${JSON.stringify(fileId)};
						export const url = ${JSON.stringify(fileUrl)};
						
						// Deferred
						export default async function load() {
							return (await import(${JSON.stringify(fileId + "?content")}));
						};
						export function Content(...args) {
							return load().then((m) => m.default(...args))
						}
						Content.isAstroComponentFactory = true;
						export function getHeaders() {
							return load().then((m) => m.metadata.headers)
						};`,
          map: null
        };
      }
      if (id.endsWith(".md")) {
        const source = await fs.promises.readFile(id, "utf8");
        const render = astroRemark;
        const renderOpts = config.markdown;
        const filename = normalizeFilename(id);
        const fileUrl = new URL(`file://${filename}`);
        const isPage = fileUrl.pathname.startsWith(resolvePages(config).pathname);
        const hasInjectedScript = isPage && config._ctx.scripts.some((s) => s.stage === "page-ssr");
        const { data: frontmatter, content: markdownContent } = matter(source);
        let renderResult = await render(markdownContent, renderOpts);
        let { code: astroResult, metadata } = renderResult;
        const _a = frontmatter, { layout = "", components = "", setup = "" } = _a, content = __objRest(_a, ["layout", "components", "setup"]);
        content.astro = metadata;
        const prelude = `---
${layout ? `import Layout from '${layout}';` : ""}
${components ? `import * from '${components}';` : ""}
${hasInjectedScript ? `import '${PAGE_SSR_SCRIPT_ID}';` : ""}
${setup}

const $$content = ${JSON.stringify(content)}
---`;
        const imports = `${layout ? `import Layout from '${layout}';` : ""}
${setup}`.trim();
        if (/\bLayout\b/.test(imports)) {
          astroResult = `${prelude}
<Layout content={$$content}>

${astroResult}

</Layout>`;
        } else {
          astroResult = `${prelude}
${astroResult}`;
        }
        let { code: tsResult } = await transform(astroResult, {
          pathname: fileUrl.pathname.substr(config.root.pathname.length - 1),
          projectRoot: config.root.toString(),
          site: config.site ? new URL(config.base, config.site).toString() : void 0,
          sourcefile: id,
          sourcemap: "inline",
          internalURL: `/@fs${new URL("../runtime/server/index.js", import.meta.url).pathname}`
        });
        tsResult = `
export const metadata = ${JSON.stringify(metadata)};
export const frontmatter = ${JSON.stringify(content)};
${tsResult}`;
        const { code } = await esbuild.transform(tsResult, {
          loader: "ts",
          sourcemap: false,
          sourcefile: id
        });
        return {
          code,
          map: null
        };
      }
      return null;
    }
  };
}
export {
  markdown as default
};
